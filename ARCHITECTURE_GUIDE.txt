================================================================================
                        PUSH_SWAP ARCHITECTURE GUIDE
================================================================================

OVERVIEW
========
Push_swap is a sorting algorithm that sorts integers using TWO STACKS (A and B)
with limited operations. The goal: move all numbers from stack A to be sorted
with minimum operations.

Example: ./push_swap 3 1 2
Output:
  pb
  pb
  ra
  pa
  pa

================================================================================
                           PROGRAM ENTRY POINT
================================================================================

main() [main.c]
│
├─ Validates command-line arguments
│  ├─ Check argc >= 2
│  ├─ Check argv[1] is not empty/spaces only
│  └─ validate_arguments() + validate_format()
│
├─ init_and_validate()
│  ├─ Allocates t_stack structure
│  ├─ Calls special_init() OR initialize_stack()
│  │  └─ Parses input and fills arr->a[] with integers
│  └─ parse_and_validate()
│     ├─ validate_no_duplicates() - rejects duplicates
│     ├─ validate_range() - ensures -2^31 to 2^31-1
│     └─ is_sorted() - checks if already sorted
│
├─ Size-based sorting decision
│  ├─ size_a == 1: Do nothing (single element is sorted)
│  ├─ size_a == 2-5: sort_small_stack() [optimal for tiny inputs]
│  └─ size_a > 5: radix_sort() [efficient for larger inputs]
│
└─ Cleanup & Exit

================================================================================
                            DATA STRUCTURES
================================================================================

t_stack structure:
┌──────────────────────────────────────────────┐
│  int *a          ─────┐  Stack A (main)      │
│  int *b          ─────┤  Stack B (auxiliary) │
│  int size_a      ─────┤  Current size of A   │
│  int size_b      ─────┤  Current size of B   │
└──────────────────────────────────────────────┘

VISUAL EXAMPLE:
Input: 3 1 2

Initial State:
┌─────┐          ┌─────┐
│  3  │ (a[0])   │     │
├─────┤          └─────┘
│  1  │ (a[1])
├─────┤
│  2  │ (a[2])
├─────┤
│  0  │ (padding)
└─────┘

================================================================================
                        OPERATION FUNCTIONS
================================================================================

STACK A OPERATIONS (operations.c):
─────────────────────────────────

sa() - SWAP A (swap top 2 elements)
  Before:  a[0]=3, a[1]=1, a[2]=2
  After:   a[0]=1, a[1]=3, a[2]=2
  Output:  "sa"

ra() - ROTATE A (move all up, last to bottom)
  Before:  a[0]=3, a[1]=1, a[2]=2
  After:   a[0]=1, a[1]=2, a[2]=3
  Output:  "ra"

rra() - REVERSE ROTATE A (move first to top, all shift down)
  Before:  a[0]=3, a[1]=1, a[2]=2
  After:   a[0]=2, a[1]=3, a[2]=1
  Output:  "rra"

pa() - PUSH A (move top of B to top of A)
  Before:  a[0]=3, a[1]=1  |  b[0]=2, b[1]=0
  After:   a[0]=2, a[1]=3, a[2]=1  |  b[0]=0
  Output:  "pa"

STACK B OPERATIONS (operations_utils.c):
────────────────────────────────────────

rb() - ROTATE B (same as ra, but for stack B)
  Before:  b[0]=2, b[1]=5
  After:   b[0]=5, b[1]=2
  Output:  "rb"

pb() - PUSH B (move top of A to top of B)
  Before:  a[0]=3, a[1]=1  |  b[0]=0
  After:   a[0]=1  |  b[0]=3, b[1]=0
  Output:  "pb"

================================================================================
                        VALIDATION PIPELINE
================================================================================

1. validate_arguments() [validate_input.c]
   ├─ For argc > 2: checks each argument
   │  └─ Ensure: optional sign, then digits only
   ├─ Returns 0 if invalid, 1 if valid
   └─ Examples:
      ✓ "42" "12" "-5"
      ✗ "42a" "5.5" ""

2. validate_format() [validate_input.c]
   ├─ For argc == 2 (quoted string): checks format
   │  └─ Format: [sign]digits[ [sign]digits]*
   ├─ Returns 0 if invalid, 1 if valid
   └─ Examples:
      ✓ "1 2 3" "1 -2 3" "-5 10"
      ✗ "1  2" "1 2a" "- 2"

3. parse_and_validate() [validate_input.c]
   ├─ validate_no_duplicates()
   │  └─ Checks arr->a[i] != arr->a[j] for all i < j
   ├─ validate_range()
   │  └─ Ensures -2147483648 <= value <= 2147483647
   ├─ is_sorted()
   │  └─ Checks if arr->a[i] <= arr->a[i+1] for all i
   └─ Returns:
      • 0 if valid (continue to sort)
      • -1 if already sorted (skip sorting)
      • 1 if invalid (error + exit)

================================================================================
                          INPUT PARSING
================================================================================

CASE 1: Multiple arguments
─────────────────────────
Command: ./push_swap 3 1 2
argc=4, argv=["./push_swap", "3", "1", "2"]

Flow:
  init_and_validate()
    └─ initialize_stack(argc=3, argv, ...)
       └─ Loop i=0 to 2:
          └─ ft_atoi_wcheck(argv[i+1]) → parse each number

CASE 2: Single quoted string
─────────────────────────────
Command: ./push_swap "3 1 2"
argc=2, argv=["./push_swap", "3 1 2"]

Flow:
  init_and_validate()
    └─ special_init("3 1 2", ...)
       ├─ ft_split("3 1 2", ' ') → ["3", "1", "2"]
       ├─ Count args (3)
       └─ initialize_stack(argc=3, split_result, ...)

================================================================================
                       CONVERSION TO INDICES
================================================================================

Why convert to indices?
  Input: 42 100 5 99
  Can't use radix sort directly (values too large)
  Solution: Map to ranked positions (0, 1, 2, 3)

Process:
────────

Step 1: Copy original values to temp array
  Original:  [42, 100, 5, 99]
  temp:      [42, 100, 5, 99]

Step 2: Find minimum, assign it index 0, replace with INT_MAX
  Iteration 1: min=5 at position 2
    indices[2] = 0
    temp[2] = INT_MAX
    temp: [42, 100, INT_MAX, 99]

Step 3: Find next minimum, assign index 1
  Iteration 2: min=42 at position 0
    indices[0] = 1
    temp[0] = INT_MAX
    temp: [INT_MAX, 100, INT_MAX, 99]

Step 4: Continue until all indexed
  Iteration 3: min=99 at position 3
    indices[3] = 2
    temp[3] = INT_MAX

  Iteration 4: min=100 at position 1
    indices[1] = 3
    temp[1] = INT_MAX

Final Result:
  Original: [42, 100, 5, 99]
  indices:  [1,  3,   0, 2]
  array->a: [1,  3,   0, 2]  ← Now we can radix sort this!

================================================================================
                         SORTING ALGORITHMS
================================================================================

FOR SMALL STACKS (size_a <= 5): sort_small_stack() [sort_small.c]
──────────────────────────────────────────────────────────────────

size_a == 1: Do nothing (already sorted)

size_a == 2: Call sa() if a[0] > a[1]
  Example: [2, 1] → sa → [1, 2]

size_a == 3: sort_three_elements()
  ┌─ Analyzes all 6 possible permutations
  ├─ [0,1,2] - sorted: do nothing
  ├─ [0,2,1] - sa
  ├─ [1,0,2] - sa then rra
  ├─ [1,2,0] - sa then ra
  ├─ [2,0,1] - ra
  └─ [2,1,0] - rra

size_a == 4: sort_four_elements()
  ├─ Find minimum element
  ├─ Rotate A so minimum is at top
  ├─ pb (push minimum to B)
  ├─ sort_three_elements() (sort remaining 3)
  └─ pa (push minimum back)

size_a == 5: sort_five_elements()
  ├─ Find minimum element
  ├─ Rotate A efficiently (ra or rra, whichever is shorter)
  ├─ pb (push minimum to B)
  ├─ sort_four_elements() (sort remaining 4)
  └─ pa (push minimum back)

Example: sort_four_elements([3, 1, 4, 2])
  ┌──────────┐          ┌──────────┐
  │ 3 (a[0]) │          │ 4 (a[0]) │
  ├──────────┤    ra    ├──────────┤
  │ 1 (a[1]) │ ─────→   │ 2 (a[1]) │
  ├──────────┤          ├──────────┤
  │ 4 (a[2]) │          │ 3 (a[2]) │
  ├──────────┤          └──────────┘
  │ 2 (a[3]) │
  └──────────┘
  
  min_index=1, so ra once to bring 1 to top
  
  Then pb → push 1 to B
  Then sort_three_elements([4, 2, 3])
  Then pa → push 1 back to top


FOR LARGE STACKS (size_a > 5): radix_sort() [sort.c]
─────────────────────────────────────────────────────

Concept: Sort by individual bits (binary representation)
  Example with 4 numbers: [0, 3, 1, 2]
  Binary:    [00, 11, 01, 10]

Radix sort processes bit by bit from LSB to MSB:

Bit 0 (rightmost):
  ┌─ Even bits (0): a[0]=0(00), a[2]=1(01) → push to B
  ├─ Odd bits (1):  a[1]=3(11), a[3]=2(10) → rotate in A
  └─ Then move all from B back to A

Bit 1:
  ┌─ Even bits (0): process again
  └─ Odd bits (1): process again

Result: Fully sorted

PSEUDOCODE:
──────────
for each bit position (0 to max_bits):
  for each element currently in A:
    if bit is 0: push to B (pb)
    if bit is 1: rotate A (ra)
  
  for each element in B:
    if bit is 0: rotate B (rb)
    if bit is 1: push back to A (pa)

================================================================================
                       MEMORY MANAGEMENT
================================================================================

Allocation (initialize_stack):
  stack = malloc(sizeof(t_stack))
  stack->a = malloc(sizeof(int) * (size + 1))
  stack->b = malloc(sizeof(int) * (size + 1))

Deallocation (free_stacks):
  free(stack->a)
  free(stack->b)
  free(stack)

Special input handling:
  args = ft_split(str, ' ')     ← allocates memory
  ... processing ...
  free_split(args)              ← deallocates all

Conversion temporary memory:
  indices = malloc(...)
  temp = malloc(...)
  ... processing ...
  free(indices)
  free(temp)

================================================================================
                         COMPLETE FLOW EXAMPLE
================================================================================

Command: ./push_swap "3 1 2"

1. main() called with argc=2, argv=["./push_swap", "3 1 2"]

2. Argument validation
   ├─ validate_arguments(2, argv) → skipped (argc==2)
   └─ validate_format(argv) → checks "3 1 2"
      └─ Returns 1 (valid format)

3. init_and_validate()
   ├─ malloc(t_stack)
   ├─ special_init("3 1 2", stack)
   │  ├─ ft_split("3 1 2", ' ') → ["3", "1", "2"]
   │  └─ initialize_stack(3, split_result, stack, args)
   │     ├─ malloc(a), malloc(b)
   │     ├─ ft_atoi_wcheck("3") → 3
   │     ├─ ft_atoi_wcheck("1") → 1
   │     ├─ ft_atoi_wcheck("2") → 2
   │     └─ stack->a = [3, 1, 2, 0]
   │        stack->size_a = 3
   │        stack->b = [0]
   │        stack->size_b = 0
   │
   └─ parse_and_validate(stack, 4)
      ├─ validate_no_duplicates() → 1 (no dupes)
      ├─ validate_range() → 1 (all in range)
      └─ is_sorted() → 0 (not sorted, return 0)

4. Sorting decision
   ├─ arr->size_a == 3
   └─ Call sort_small_stack(arr)
      └─ Call sort_three_elements(arr)
         ├─ first=3, second=1, third=2
         ├─ Matches pattern: first > second && second < third && first > third
         └─ Call ra()
            ├─ a[0]=1, a[1]=2, a[2]=3
            └─ Output: "ra"

5. Cleanup
   └─ free_stacks(stack)

FINAL OUTPUT:
─────────────
ra

RESULT: [1, 2, 3] ✓ Sorted!

================================================================================
                      FUNCTION DEPENDENCY GRAPH
================================================================================

main()
├─ validate_arguments()
├─ validate_format()
├─ init_and_validate()
│  ├─ special_init()
│  │  ├─ ft_split()
│  │  ├─ initialize_stack()
│  │  │  └─ ft_atoi_wcheck()
│  │  └─ free_split()
│  ├─ initialize_stack()
│  │  └─ ft_atoi_wcheck()
│  └─ parse_and_validate()
│     ├─ validate_no_duplicates()
│     ├─ validate_range()
│     └─ is_sorted()
├─ is_sorted()
├─ convert_to_indices()
│  ├─ find_min_pos()
│  └─ build_index_map()
├─ sort_small_stack()
│  ├─ sa()
│  ├─ sort_three_elements()
│  │  ├─ sa()
│  │  ├─ ra()
│  │  └─ rra()
│  ├─ sort_four_elements()
│  │  ├─ ra()
│  │  ├─ pb()
│  │  ├─ sort_three_elements()
│  │  └─ pa()
│  └─ sort_five_elements()
│     ├─ ra()
│     ├─ rra()
│     ├─ pb()
│     ├─ sort_four_elements()
│     └─ pa()
├─ radix_sort()
│  ├─ get_max_bits()
│  ├─ pb()
│  ├─ ra()
│  ├─ radix_sort_b()
│  │  ├─ rb()
│  │  ├─ pa()
│  │  └─ is_sorted()
│  └─ pa()
└─ free_stacks()

================================================================================
                         KEY INSIGHTS
================================================================================

1. DUAL STACK STRATEGY
   ├─ Stack A: Main storage (initially all numbers)
   ├─ Stack B: Temporary storage for intermediate sorting
   └─ Use B to efficiently rearrange A

2. BIT-LEVEL SORTING (Radix)
   ├─ Process binary representation bit by bit
   ├─ Much faster than bubble/insertion for large sets
   └─ O(n*k) where k=number of bits, not O(n²)

3. GREEDY SMALL SORTING
   ├─ For n≤5, direct strategies are faster
   ├─ Avoid unnecessary operations
   └─ Hardcoded moves for all permutations

4. INDEX NORMALIZATION
   ├─ Convert any range of numbers to 0 to n-1
   ├─ Makes radix sort work with negative numbers
   └─ Essential for handling INT_MAX/INT_MIN

5. VALIDATION LAYERS
   ├─ Argument format → basic syntax
   ├─ Duplicates → logical correctness
   ├─ Range → type constraints
   └─ Already sorted → early optimization

================================================================================
